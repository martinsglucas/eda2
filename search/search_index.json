{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Estrutura de Dados 2","text":""},{"location":"#sumario","title":"Sum\u00e1rio","text":"<ol> <li>Revis\u00e3o</li> <li>Problema de Busca</li> <li>Tabela Hash</li> <li>\u00c1rvores</li> <li>Red Black</li> <li>Fila de Prioridades</li> <li>Grafos</li> </ol>"},{"location":"arvore/arvores/","title":"\u00c1rvores","text":"<p>Ir para o Sum\u00e1rio</p>"},{"location":"arvore/arvores/#arvores","title":"\u00c1rvores","text":""},{"location":"arvore/arvores/#arvore","title":"\u00c1rvore","text":"<p>S\u00e3o estruturas compostas por n\u00f3s interligados entre si de tal forma que:</p> <ul> <li>Um n\u00f3 pode ter um \u00fanico antecessor. H\u00e1 apenas um n\u00f3 que n\u00e3o possui antecessor e se chama raiz;</li> <li>Um n\u00f3 pode ter zero ou mais filhos. Um n\u00f3 que n\u00e3o tem filhos \u00e9 chamado de folha;</li> </ul> <p>Exemplo:</p> <pre><code>\ngraph TD\n    A((A)) --&gt; B((B))\n    A --&gt; C((C))\n    A --&gt; D((D))\n\n    B --&gt; E((E))\n    E --&gt; F((F))\n    E --&gt; G((G))\n    E --&gt; H((H))\n\n    C --&gt; I((I))\n    C --&gt; J((J))\n    C --&gt; K((K))\n    C --&gt; L((L))\n\n    I --&gt; M((M))\n    I --&gt; N((N))\n\n    M --&gt; V((V))\n\n    J --&gt; O((O))\n    J --&gt; P((P))\n    J --&gt; Q((Q))\n\n    L --&gt; R((R))\n    L --&gt; S((S))\n\n    S --&gt; T((T))\n\n    D --&gt; U((U))\n</code></pre> <p>No exemplo acima, a \u00e1rvore possui os n\u00edveis 0, 1, 2, 3, e 4. O n\u00edvel 0 \u00e9 a raiz</p> N\u00edvel 0 A N\u00edvel 1 B, C, D N\u00edvel 2 E, I, J, K, L, U N\u00edvel 3 F, G, H, M, N, O, P, Q, R, S N\u00edvel 4 V, T <p>A \u00e1rvore \u00e9 uma estrutura criada tamb\u00e9m para a resolu\u00e7\u00e3o do problema de busca (para a otimiza\u00e7\u00e3o de buscas e armazenamento de dados).</p>"},{"location":"arvore/arvores/#arvore-binaria","title":"\u00c1rvore Bin\u00e1ria","text":"<p>S\u00e3o \u00e1rvores em que cada n\u00f3 pode ter, no m\u00e1ximo, dois filhos.</p> <pre><code>\ngraph TD\n    A((A)) --&gt; B((B))\n    A --&gt; C((C))\n\n    B --&gt; D((D))\n    B --&gt; E((E))\n\n    C --&gt; F((F))\n    C --&gt; G((G))\n\n    D --&gt; H((H))\n\n    E --&gt; I((I))\n    E --&gt; J((J))\n\n    F --&gt; K((K))\n    F --&gt; L((L))\n\n    K --&gt; N((N))\n    K --&gt; O((O))\n\n    G --&gt; M((M))    </code></pre> <p>Um n\u00edvel k pode ter no m\u00e1ximo 2^k n\u00f3s. </p> <p>Uma \u00e1rvore com n n\u00f3s tem, no m\u00ednimo, \\log_2n n\u00edveis e, no m\u00e1ximo, n n\u00edveis.</p> 2^0 + 2^1 + 2^2 + 2^3 + ... + 2^{k-1} = n n = \\frac{1(2^k-1)}{2-1} = 2^k-1 <p>n = 2^k. k \u00e9 O(logn)</p>"},{"location":"arvore/arvores/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Uma forma de implementar uma \u00e1rvore bin\u00e1ria \u00e9 atrav\u00e9s de lista encadeada.</p> <pre><code>typedef struct no {\n    int dado;\n    struct no *esq;\n    struct no *dir;\n} no;\n\nno *raiz;\n</code></pre>"},{"location":"arvore/arvores/#distancia","title":"Dist\u00e2ncia","text":"<p>A dist\u00e2ncia entre dois n\u00f3s \u00e9 a quantidade de arestas (liga\u00e7\u00f5es) que os unem.</p>"},{"location":"arvore/arvores/#altura","title":"Altura","text":"<p>A altura de um n\u00f3 \u00e9 a maior dist\u00e2ncia entre este n\u00f3 e uma folha da \u00e1rvore. A altura da \u00e1rvore \u00e9 a altura da raiz.</p> <p>Altura da \u00e1rvore = Quantidade de n\u00edveis - 1</p> <p>Exemplo:</p> <pre><code>\ngraph TD\n    A((A)) --&gt; B((B))\n    A --&gt; C((C))\n\n    B --&gt; D((D))\n    B --&gt; E((E))\n\n    C --&gt; F((F))\n    C --&gt; G((G))\n\n    D --&gt; H((H))\n    D --&gt; I((I))\n\n    E --&gt; J((J))\n    E --&gt; K((K))\n\n    F --&gt; L((L))\n    F --&gt; M((M))\n\n    G --&gt; N((N))\n    G --&gt; O((O))\n\n    H --&gt; P((P))\n\n    K --&gt; Q((Q))\n\n    P --&gt; R((R))\n    P --&gt; S((S))</code></pre> <p>A altura do n\u00f3 B, por exemplo, \u00e9 4.</p> <p>Vale notar que o n\u00f3 B tem dist\u00e2ncia 2 para os n\u00f3s folhas I e J, dist\u00e2ncia 3 para o n\u00f3 folha Q e dist\u00e2ncia 4 para os n\u00f3s folhas R e S. Logo a altura do n\u00f3 B \u00e9 4 (maior dist\u00e2ncia).</p> <pre><code>int altura(no *raiz){\n    if (raiz == NULL) return -1; // por conven\u00e7\u00e3o (se retornar 0, a altura seria 1)\n    else {\n        int he = altura(raiz-&gt;esq);\n        int hd = altura(raiz-&gt;dir);\n        if (he &gt; hd) return he + 1;\n        else return hd + 1;\n    }\n}\n// como o algoritmo percorre todos os n\u00f3s da \u00e1rvore, para n n\u00f3s a complexidade \u00e9 O(n)\n// Esse algoritmo pode ser implementado de forma iterativa tamb\u00e9m, usando uma pilha (ou fila) para armazenar os n\u00f3s que precisam ser visitados. Quando for para um lado, empilha o n\u00f3 do outro lado.\n</code></pre>"},{"location":"arvore/arvores/#balanceamento","title":"Balanceamento","text":"<p>Uma \u00e1rvore \u00e9 dita balanceada se:</p> <ol> <li>cada n\u00f3 possui \"aproximadamente\" a mesma altura; ou</li> <li>A altura da \u00e1rvore \u00e9 O(logn).</li> </ol>"},{"location":"arvore/arvores/#percursos-em-arvores-binarias","title":"Percursos em \u00c1rvores Bin\u00e1rias","text":""},{"location":"arvore/arvores/#1-profundidade","title":"1. Profundidade","text":"<p>Visam alcan\u00e7ar folhas o quanto antes. H\u00e1 3 tipos comuns:</p> <p>visita: faz alguma opera\u00e7\u00e3o</p>"},{"location":"arvore/arvores/#11-pre-ordem","title":"1.1 Pr\u00e9-ordem","text":"<ul> <li>\"visita\" raiz</li> <li>esquerda</li> <li>direita</li> </ul>"},{"location":"arvore/arvores/#12-em-ordem","title":"1.2 Em ordem","text":"<ul> <li>esquerda</li> <li>\"visita\" raiz</li> <li>direita</li> </ul>"},{"location":"arvore/arvores/#13-pos-ordem","title":"1.3 P\u00f3s-ordem","text":"<ul> <li>esquerda</li> <li>direita</li> <li>\"visita\" raiz</li> </ul>"},{"location":"arvore/arvores/#exemplo","title":"Exemplo","text":"<pre><code>    graph TD\n        10 --&gt; 3\n        10 --&gt; 4\n\n        3 --&gt; 7\n        3 --&gt; 6\n\n        7 --&gt; 8\n        7 --&gt; 9\n\n        6 --&gt; A[NULL]\n        6 --&gt; 13\n        13 --&gt; 11\n        13 --&gt; B[NULL]\n\n        4 --&gt; 5\n        4 --&gt; 1\n\n        5 --&gt; 12\n        5 --&gt; C[NULL]\n\n        12 --&gt; D[NULL]\n        12 --&gt; 15\n\n        1 --&gt; E[NULL]\n        1 --&gt; 2\n</code></pre> <ul> <li>Pr\u00e9-ordem: 10, 3, 7, 8, 9, 6, 13, 11, 4, 5, 12, 15, 1, 2</li> <li>Em ordem: 8, 7, 9, 3, 6, 11, 13, 10, 12, 15, 5, 4, 1, 2</li> <li>P\u00f3s-ordem: 8, 9, 7, 11, 13, 6, 3, 15, 12, 5, 2, 1, 4, 10</li> </ul>"},{"location":"arvore/arvores/#2-largura","title":"2. Largura","text":"<p>O percurso em largura \u00e9 um algoritmo que percorre a \u00e1rvore n\u00edvel por n\u00edvel. Em uma \u00e1rvore bin\u00e1ria, isso pode ser implementado usando uma fila. </p> <p>O algoritmo funciona adicionando a raiz \u00e0 fila e, em seguida, entrando em um loop que continua at\u00e9 que a fila esteja vazia. Em cada itera\u00e7\u00e3o do loop, ele remove o n\u00f3 do in\u00edcio da fila, imprime seu valor e adiciona seus filhos \u00e0 fila.</p>"},{"location":"arvore/arvores/#arvore-binaria-de-busca","title":"\u00c1rvore Bin\u00e1ria de Busca","text":"<p>\u00c9 uma \u00e1rvore bin\u00e1ria tal que, para cada n\u00f3 <code>v</code> da \u00e1rvore, vale que:</p> \\text{e.chave} \\leq \\text{v.chave} \\leq \\text{d.chave} <p>para qualquer n\u00f3 <code>e</code> (respectivamente <code>d</code>) pertencente \u00e0 sub\u00e1rvore esquerda de <code>v</code>. (respectivamente direita de <code>v</code>).</p> <p> <pre><code>    graph TD\n        A[v] --&gt; B[e]\n        A --&gt; C[d]\n</code></pre> <p></p>"},{"location":"arvore/arvores/#busca","title":"Busca","text":"<pre><code>no *busca(no *r, int x){\n    if (r == NULL || r-&gt;chave == x) return r;\n    else{\n        if (x &lt; r-&gt;chave) busca(r-&gt;esq, x);\n        else busca(r-&gt;dir, x);\n    }\n\n}\nno busca(no *r, int x){\n    while (r != NULL || r-&gt;chave != x){\n        if (x &lt; r-&gt;chave) r = r-&gt;esq;\n        else r = r-&gt;dir;\n    }\n    return r;\n} // complexidade O(log n) para uma \u00e1rvore balanceada, O(n) caso contr\u00e1rio\n</code></pre>"},{"location":"arvore/arvores/#insercao","title":"Inser\u00e7\u00e3o","text":"<p>Inserir a chave no 9 do exemplo abaixo</p> <pre><code>    graph TD\n        A[10] --&gt;|menor que 10| B[4]\n        A --&gt; C[15]\n\n        B --&gt; D[1]\n        B --&gt;|maior que 4| E[8]\n\n        C --&gt; F[12]\n        C --&gt; G[18]\n\n        F --&gt; O[NULL]\n        F --&gt; N[13]\n\n        G --&gt; H[16]\n        G --&gt; I[20]\n\n        H --&gt; J[NULL]\n        H --&gt; K[17]\n\n        E --&gt; L[5]\n        E --&gt;|maior que 8| M[9]\n\n        style M fill:#f00,stroke:#333,stroke-width:4px\n</code></pre> <pre><code>no *insere(no *r, int y){\n    if (r == NULL){\n        no *novo = (no *) malloc(sizeof(no));\n        novo-&gt;chave = y;\n        novo-&gt;esq = novo-&gt;dir = NULL;\n        return novo;\n    }\n    else if (y &lt; r-&gt;chave) r-&gt;esq = insere(r-&gt;esq, y);\n    else if (y &gt; r-&gt;chave)r-&gt;dir = insere(r-&gt;dir, y);\n    /* fa\u00e7a o que for necess\u00e1rio com a igualdade aqui */\n    /* na pr\u00e1tica n\u00e3o se insere chaves duplicadas, mas faz alguma manipula\u00e7\u00e3o ou atualiza\u00e7\u00e3o */\n    return r;\n}\n</code></pre>"},{"location":"arvore/arvores/#remocao","title":"Remo\u00e7\u00e3o","text":"<p>vermelho: elemento a ser removido verde: elementos candidatos a ocuparem o lugar do elemento removido</p> <pre><code>    graph TD\n        A[10] --&gt; B[4]\n        A --&gt; C[15]\n\n        B --&gt; D[1]\n        B --&gt; E[8]\n\n        C --&gt; F[12]\n        C --&gt; G[18]\n\n        F --&gt; O[NULL]\n        F --&gt; N[13]\n\n        G --&gt; H[16]\n        G --&gt; I[20]\n\n        H --&gt; J[NULL]\n        H --&gt; K[17]\n\n        E --&gt; L[5]\n        E --&gt; M[9]\n\n        style C fill:#f00,stroke:#333,stroke-width:4px\n        style H fill:#3f0,stroke:#333,stroke-width:4px\n        style N fill:#3f0,stroke:#333,stroke-width:4px\n</code></pre> <p>Essa \u00e1rvore, percorrida em ordem, \u00e9: 0,1,4,5,8,9,10,12,13,15,16,17,18,20</p>"},{"location":"arvore/arvores/#passos","title":"Passos","text":"<ol> <li>Encontrar o n\u00f3 <code>v</code></li> <li>Encontre o n\u00f3 <code>z</code> que o seja maior da sub\u00e1rvore esquerda de <code>v</code> ou o menor da sub\u00e1rvore direita de <code>v</code></li> <li>Troca <code>v</code>com <code>z</code> (complexidade O(1))<ul> <li>isso conserva a propriedade de \u00e1rvore bin\u00e1ria de busca</li> </ul> </li> <li> <p>Remova <code>v</code> (complexidade O(1))</p> </li> <li> <p>Passo 1 + 2:</p> <ul> <li>O(log n) se balanceada</li> <li>O(n) caso contr\u00e1rio </li> </ul> </li> </ol>"},{"location":"arvore/arvores/#implementacao_1","title":"Implementa\u00e7\u00e3o","text":"<pre><code>no *remove(no *r, int x){\n    if (r-&gt;esq != NULL){\n        no *p = r, *q = r-&gt;esq;\n        // encontrar o maior da sub\u00e1rvore esquerda\n        while (q-&gt;dir != NULL){\n            p = q;\n            q = q-&gt;dir;\n        }\n        r-&gt;chave = q-&gt;chave;\n        if (p == r) p-&gt;esq = q-&gt;esq;\n        else p-&gt;dir = q-&gt;esq;\n        free(q);\n        return r;\n    }\n    else {\n        no *q = r-&gt;dir;\n        free(r);\n        return q;\n    }\n}\n</code></pre>"},{"location":"arvore/filaPrioridade/","title":"Fila de Prioridade","text":"<p>Ir para o Sum\u00e1rio</p>"},{"location":"arvore/filaPrioridade/#fila-de-prioridades","title":"Fila de Prioridades","text":"<p>Uma fila de prioridades \u00e9 uma estrutura de dados que possui duas opera\u00e7\u00f5es:</p> <ol> <li>Inser\u00e7\u00e3o</li> <li>Remo\u00e7\u00e3o do elemento de maior prioridade</li> </ol> <p>Para implementa\u00e7\u00e3o, haveria duas possibilidades: procurar o de maior prioridade para remover (que custa O(n)) ou inserir a maior prioridade no in\u00edcio da fila ou topo da pilha (que custaria O(n) para calcular a posi\u00e7\u00e3o)</p> <p>Implementar fila de prioridades usando vetores ou listas encadeadas implica um custo de O(n) para alguma das duas opera\u00e7\u00f5es acima</p>"},{"location":"arvore/filaPrioridade/#fp-usando-arvores","title":"FP usando \u00e1rvores","text":"<p>Para implementar FP com \u00e1rvores, vamos usar \u00e1rvores bin\u00e1rias completas: \u00e1rvores em que todos os n\u00edveis possuem o m\u00e1ximo de n\u00f3s, com exce\u00e7\u00e3o, talvez, do \u00faltimo.</p> <pre><code>graph TD\n    1 --&gt; 2\n    1 --&gt; 3\n    2 --&gt; 4\n    2 --&gt; 5\n    3 --&gt; 6\n    3 --&gt; 7\n    4 --&gt; 8\n    4 --&gt; 9\n    5 --&gt; 10\n    5 --&gt; 11\n    6 --&gt; 12\n    6 --&gt; 13\n    7 --&gt; 14\n    7 --&gt; 15\n    8 --&gt; 16\n    8 --&gt; 17\n    9 --&gt; 18\n    9 --&gt; NULL</code></pre>"},{"location":"arvore/filaPrioridade/#implementacao-de-arvores-completas","title":"Implementa\u00e7\u00e3o de \u00e1rvores completas","text":"<pre><code>graph TD\n    v0 --&gt; v1\n    v0 --&gt; v2\n    v1 --&gt; v3\n    v1 --&gt; v4\n    v2 --&gt; v5\n    v2 --&gt; v6\n    v3 --&gt; v7\n    v3 --&gt; v8\n    v4 --&gt; v9</code></pre> <p>Dado um n\u00f3 <code>v[i]</code> da \u00e1rvore:</p> <ul> <li>pai: <code>v[(i-1)/2]</code></li> <li>filho esquerdo: <code>v[2*i+1]</code></li> <li>filho direito: <code>v[2*i+2]</code></li> </ul>"},{"location":"arvore/filaPrioridade/#fp-com-arvores-completas","title":"FP com \u00e1rvores completas","text":"<p>A \u00e1rvore seria tal que a raiz \u00e9 maior que seus filhos.</p> <p>Maior pode ser entendido como maior prioridade, ou seja, a raiz \u00e9 o elemento de maior prioridade</p> <p>Exemplo</p> <pre><code>graph TD\n    10 --&gt; 9\n    10 --&gt; 4\n    9 --&gt; 7\n    9 --&gt; 8\n    7 --&gt; 6\n    7 --&gt; 1\n    8 --&gt; 5\n    4 --&gt; 2\n    4 --&gt; 3</code></pre> <p>Esse \u00e9 um heap de m\u00e1ximo, ou seja, a raiz \u00e9 o elemento de maior prioridade</p>"},{"location":"arvore/filaPrioridade/#implementacao","title":"Implementa\u00e7\u00e3o","text":""},{"location":"arvore/filaPrioridade/#insercao","title":"Inser\u00e7\u00e3o","text":"<pre><code>typedef struct {\n    int *chaves;\n    int n, tam; // tam \u00e9 a capacidade, n \u00e9 a quantidade\n} FP;\n\nFP *cria_fila(int tam){\n    FP *fp = (FP *) malloc(sizeof(FP));\n    fp-&gt;chaves = (int *) malloc(tam * sizeof(int));\n    fp-&gt;n = 0;\n    fp-&gt;tam = tam;\n    return fp;\n}\nvoid sobe_no_heap(FP *fp){\n    int k = fp-&gt;n-1;\n    int pai = (k-1)/2;\n    while (k &gt; 0 &amp;&amp; fp-&gt;chaves[pai] &lt; fp-&gt;chaves[k]){\n        troca(&amp;fp-&gt;chaves[pai], &amp;fp-&gt;chaves[k]);\n        k = pai;\n        pai = (k-1)/2;\n    }\n} // complexidade O(log n)\nvoid insere(FP *fp, int x){\n    if(fp-&gt;n + 1 &gt;= fp-&gt;tam){ // O(tam)??\n        // S\u00f3 acontece a cada tam inser\u00e7\u00f5es\n        // Olhando amortizadamente, essa opera\u00e7\u00e3o torna-se O(1)\n        fp-&gt;tam *= 2;\n        fp-&gt;chaves = (int *) realloc(fp-&gt;chaves, fp-&gt;tam*sizeof(int));\n    }\n    fp-&gt;chaves[fp-&gt;n] = x;\n    fp-&gt;n++;\n    sobe_no_heap(fp);\n} // complexidade O(log n)\n</code></pre>"},{"location":"arvore/filaPrioridade/#remocao","title":"Remo\u00e7\u00e3o","text":"<pre><code>int maior(FP *fp, int k, int e, int d, int *m){\n    int valor = fp-&gt;chaves[k];\n    if (e &lt; fp-&gt;n){\n        if (fp-&gt;chaves[e] &gt; fp-&gt;chaves[k]){\n            *m = e;\n            valor = fp-&gt;chaves[e];\n        }\n        if (d &lt; fp-&gt;n &amp;&amp; fp-&gt;chaves[d] &gt; valor){\n            *m = d;\n            valor = fp-&gt;chaves[d];\n        }\n    }\n    return valor;\n} // melhorar: remover esq e dir como parametro\nint extrai_maximo(Fp *fp){\n    if (fp-&gt;n &gt; 0){\n        fp-&gt;n--;\n        troca(&amp;fp-&gt;chaves[0], &amp;fp-&gt;chaves[fp-&gt;n]);\n        int k=0, esq = 2*k+1, dir = esq+1, m;\n        // condi\u00e7\u00e3o de descida\n        while (maior(fp, k, esq, dir, &amp;m) &gt; fp-&gt;chaves[k]){\n            troca(&amp;fp-&gt;chaves[k], &amp;fp-&gt;chaves[m]);\n            k = m;\n            esq = 2*k+1;\n            dir = esq+1;\n        }\n        return fp-&gt;chaves[fp-&gt;n];\n    }\n    return 0;\n}\n// condi\u00e7\u00e3o antiga do while: esq &lt; fp-&gt;n &amp;&amp; fp-&gt;chaves[esq] &gt; fp-&gt;chaves[k] || dir &lt; fp-&gt;n &amp;&amp; fp-&gt;chaves[dir] &gt; fp-&gt;chaves\n</code></pre>"},{"location":"arvore/redblack/","title":"Red Black","text":"<p>Ir para o Sum\u00e1rio</p>"},{"location":"arvore/redblack/#arvore-rubro-negra-esquerdistas-red-black","title":"\u00c1rvore rubro-negra esquerdistas (Red-Black)","text":"<p>\u00c9 uma \u00e1rvore bin\u00e1ria de busca (ABB) que satisfaz as seguintes condi\u00e7\u00f5es:</p> <ol> <li>Todo n\u00f3 \u00e9 vermelho ou preto  </li> <li>A raiz \u00e9 preta</li> <li>As folhas s\u00e3o NULL e pretas</li> <li>Se um n\u00f3 \u00e9 vermelho, ent\u00e3o:<ul> <li>Seus dois filhos s\u00e3o pretos</li> <li>\u00c9 filho esquerdo de um n\u00f3 preto</li> </ul> </li> <li>Para qualquer n\u00f3, todo caminho que o liga a uma folha tem a mesma quantidade de n\u00f3s pretos <ul> <li>n\u00e3o contamos o pr\u00f3prio n\u00f3</li> <li>chamamos isso de altura negra</li> </ul> </li> </ol> <p>Toda aresta que chega a um n\u00f3 recebe a mesma cor desse n\u00f3</p>"},{"location":"arvore/redblack/#representacao","title":"Representa\u00e7\u00e3o","text":"<pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        14:::black --&gt; 10:::red\n        14 --&gt; 16:::black\n\n        10 --&gt; 7:::black\n        10 --&gt; 12:::black\n\n        16 --&gt; 15:::red\n        16 --&gt; A[NULL]:::black\n\n        7 --&gt; 3:::red\n        7 --&gt; B[NULL]:::black\n\n        12 --&gt; C[NULL]:::black\n        12 --&gt; D[NULL]:::black\n\n        15 --&gt; E[NULL]:::black\n        15 --&gt; F[NULL]:::black\n\n        3 --&gt; G[NULL]:::black\n        3 --&gt; H[NULL]:::black</code></pre> <p>Sendo <code>bh</code> a altura negra da \u00e1rvore. Portanto h\u00e1, no m\u00ednimo,</p> 2^{bh}-1 <p>n\u00f3s. Por outro lado, </p> bh \\ge \\frac{h}{2} <p>Logo,</p> n \\ge 2^{bh}-1 \\ge 2^{\\frac{h}{2}}-1 n \\ge 2^{\\frac{h}{2}} \\log_2n \\ge \\frac{h}{2} h \\le 2\\log_2n"},{"location":"arvore/redblack/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>typedef enum {VERMELHOR, PRETO} cor;\n\ntypedef struct no {\n    int chave;\n    cor cor;\n    struct no *esq, *dir;\n} no;\n</code></pre>"},{"location":"arvore/redblack/#insercao","title":"Inser\u00e7\u00e3o","text":"<p>Todo n\u00f3 inserido recebe a cor vermelha, pois assim n\u00e3o altera-se a altura negra da \u00e1rvore.</p> <pre><code>no *insere(no *r, int x){\n    if (r == NULL){\n        no *novo = (no *) calloc(1, sizeof(no));\n        novo-&gt;chave = x;\n        novo-&gt;cor = VERMELHO;\n        return novo;\n    } else if (x &lt; r-&gt;chave) r-&gt;esq = insere(r-&gt;esq, x);\n    else if (x &gt; r-&gt;chave) r-&gt;dir = insere(r-&gt;dir, x);\n    /* corre\u00e7\u00e3o da sub\u00e1rvore com raiz r */\n    return r;\n}\n</code></pre>"},{"location":"arvore/redblack/#correcoes","title":"Corre\u00e7\u00f5es","text":""},{"location":"arvore/redblack/#subir-cor","title":"Subir cor","text":"<pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        1[A]:::black --&gt; 2[B]:::red\n        1 --&gt; 3[C]:::red\n</code></pre>  \u2192   <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        4[A]:::red --&gt; 5[B]:::black\n        4 --&gt; 6[C]:::black\n\n</code></pre>"},{"location":"arvore/redblack/#rotacao-a-esquerda","title":"Rota\u00e7\u00e3o \u00e0 esquerda","text":"<pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        1[X]:::black --&gt; 2[Sub A]\n        1 --&gt; 3[Y]:::red\n\n        3 --&gt; 4[Sub B]\n        3 --&gt; 5[Sub C]\n</code></pre>  \u2192  <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        1[Y]:::black --&gt; 2[X]:::red\n        1 --&gt; 3[Sub C]\n\n        2 --&gt; 4[Sub A]\n        2 --&gt; 5[Sub B]\n</code></pre> <p>O que desce, desce vermelho. O que sobe, assume a cor do pai</p>"},{"location":"arvore/redblack/#rotacao-a-direita","title":"Rota\u00e7\u00e3o \u00e0 direita","text":"<pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        1[X]:::black --&gt; 2[Y]:::red\n        1 --&gt; 3[Sub C]\n\n        2 --&gt; 4[Sub A]\n        2 --&gt; 5[Sub B]\n</code></pre>  \u2192  <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        1[Y]:::black --&gt; 2[Sub A]\n        1 --&gt; 3[X]:::red\n\n        3 --&gt; 4[Sub B]\n        3 --&gt; 5[Sub C]\n</code></pre>"},{"location":"arvore/redblack/#casos","title":"Casos","text":""},{"location":"arvore/redblack/#filho-esquerdo-de-um-no-preto","title":"Filho esquerdo de um n\u00f3 preto","text":"<p>Do exemplo anterior, e supondo que queiramos inserir o n\u00f3 11</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        14:::black --&gt; 10:::red\n        14 --&gt; 16:::black\n\n        10 --&gt; 7:::black\n        10 --&gt; 12:::black\n\n        16 --&gt; 15:::red\n        16 --&gt; A[NULL]:::black\n\n        7 --&gt; 3:::red\n        7 --&gt; B[NULL]:::black\n\n        12 --&gt; 11:::red\n        12 --&gt; D[NULL]:::black\n\n        15 --&gt; E[NULL]:::black\n        15 --&gt; F[NULL]:::black\n\n        3 --&gt; G[NULL]:::black\n        3 --&gt; H[NULL]:::black\n\n        11 --&gt; C[NULL]:::black\n        11 --&gt; I[NULL]:::black</code></pre>"},{"location":"arvore/redblack/#filho-direito-de-um-no-preto-correcao-sobe-a-cor-do-pai-irmao-vermelho","title":"Filho direito de um n\u00f3 preto. Corre\u00e7\u00e3o: sobe a cor do pai (irm\u00e3o vermelho)","text":"<p>Agora, vamos inserir o n\u00f3 20</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        14:::black --&gt; 10:::red\n        14 --&gt; 16:::black\n\n        10 --&gt; 7:::black\n        10 --&gt; 12:::black\n\n        16 --&gt; 15:::red\n        16 --&gt; 20:::red\n\n        7 --&gt; 3:::red\n        7 --&gt; B[NULL]:::black\n\n        12 --&gt; 11:::red\n        12 --&gt; D[NULL]:::black\n\n        15 --&gt; E[NULL]:::black\n        15 --&gt; F[NULL]:::black\n\n        20 --&gt; A[NULL]:::black\n        20 --&gt; J[NULL]:::black\n\n        3 --&gt; G[NULL]:::black\n        3 --&gt; H[NULL]:::black\n\n        11 --&gt; C[NULL]:::black\n        11 --&gt; I[NULL]:::black</code></pre> <p>Problema: o 20 \u00e9 filho direito. Corre\u00e7\u00e3o: Subir a cor</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        14:::black --&gt; 10:::red\n        14 --&gt; 16:::red\n\n        10 --&gt; 7:::black\n        10 --&gt; 12:::black\n\n        16 --&gt; 15:::black\n        16 --&gt; 20:::black\n\n        7 --&gt; 3:::red\n        7 --&gt; B[NULL]:::black\n\n        12 --&gt; 11:::red\n        12 --&gt; D[NULL]:::black\n\n        15 --&gt; E[NULL]:::black\n        15 --&gt; F[NULL]:::black\n\n        20 --&gt; A[NULL]:::black\n        20 --&gt; J[NULL]:::black\n\n        3 --&gt; G[NULL]:::black\n        3 --&gt; H[NULL]:::black\n\n        11 --&gt; C[NULL]:::black\n        11 --&gt; I[NULL]:::black</code></pre> <p>Temos o mesmo problema, ent\u00e3o subimos a cor novamente. No entanto, mantemos a raiz com a cor preta</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        14:::black --&gt; 10:::black\n        14 --&gt; 16:::black\n\n        10 --&gt; 7:::black\n        10 --&gt; 12:::black\n\n        16 --&gt; 15:::black\n        16 --&gt; 20:::black\n\n        7 --&gt; 3:::red\n        7 --&gt; B[NULL]:::black\n\n        12 --&gt; 11:::red\n        12 --&gt; D[NULL]:::black\n\n        15 --&gt; E[NULL]:::black\n        15 --&gt; F[NULL]:::black\n\n        20 --&gt; A[NULL]:::black\n        20 --&gt; J[NULL]:::black\n\n        3 --&gt; G[NULL]:::black\n        3 --&gt; H[NULL]:::black\n\n        11 --&gt; C[NULL]:::black\n        11 --&gt; I[NULL]:::black</code></pre>"},{"location":"arvore/redblack/#filho-direito-de-um-no-preto-correcao-rotacao-a-esquerda-irmao-preto","title":"Filho direito de um n\u00f3 preto. Corre\u00e7\u00e3o: rota\u00e7\u00e3o \u00e0 esquerda (irm\u00e3o preto)","text":"<p>Inserir o 17</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        14:::black --&gt; 10:::black\n        14 --&gt; 16:::black\n\n        10 --&gt; 7:::black\n        10 --&gt; 12:::black\n\n        16 --&gt; 15:::black\n        16 --&gt; 20:::black\n\n        7 --&gt; 3:::red\n        7 --&gt; B[NULL]:::black\n\n        12 --&gt; 11:::red\n        12 --&gt; D[NULL]:::black\n\n        15 --&gt; E[NULL]:::black\n        15 --&gt; 17:::red\n\n        20 --&gt; A[NULL]:::black\n        20 --&gt; J[NULL]:::black\n\n        3 --&gt; G[NULL]:::black\n        3 --&gt; H[NULL]:::black\n\n        11 --&gt; C[NULL]:::black\n        11 --&gt; I[NULL]:::black\n\n        17 --&gt; F[NULL]:::black\n        17 --&gt; K[NULL]:::black</code></pre> <p>Aplicamos a rota\u00e7\u00e3o \u00e0 esquerda</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        14:::black --&gt; 10:::black\n        14 --&gt; 16:::black\n\n        10 --&gt; 7:::black\n        10 --&gt; 12:::black\n\n        16 --&gt; 17:::black\n        16 --&gt; 20:::black\n\n        7 --&gt; 3:::red\n        7 --&gt; B[NULL]:::black\n\n        12 --&gt; 11:::red\n        12 --&gt; D[NULL]:::black\n\n        17 --&gt; 15:::red\n        17 --&gt; E[NULL]:::black\n\n        20 --&gt; A[NULL]:::black\n        20 --&gt; J[NULL]:::black\n\n        3 --&gt; G[NULL]:::black\n        3 --&gt; H[NULL]:::black\n\n        11 --&gt; C[NULL]:::black\n        11 --&gt; I[NULL]:::black\n\n        15 --&gt; F[NULL]:::black\n        15 --&gt; K[NULL]:::black</code></pre>"},{"location":"arvore/redblack/#filho-esquerdo-de-um-no-vermelho-correcao-rotacao-a-direita-no-pai-preto-e-sobe-cor","title":"Filho esquerdo de um n\u00f3 vermelho. Corre\u00e7\u00e3o: rota\u00e7\u00e3o \u00e0 direita no pai preto e sobe cor","text":"<p>Inserir o 1</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        14:::black --&gt; 10:::black\n        14 --&gt; 16:::black\n\n        10 --&gt; 7:::black\n        10 --&gt; 12:::black\n\n        16 --&gt; 17:::black\n        16 --&gt; 20:::black\n\n        7 --&gt; 3:::red\n        7 --&gt; B[NULL]:::black\n\n        12 --&gt; 11:::red\n        12 --&gt; D[NULL]:::black\n\n        17 --&gt; 15:::red\n        17 --&gt; E[NULL]:::black\n\n        20 --&gt; A[NULL]:::black\n        20 --&gt; J[NULL]:::black\n\n        3 --&gt; 1:::red\n        3 --&gt; H[NULL]:::black\n\n        11 --&gt; C[NULL]:::black\n        11 --&gt; I[NULL]:::black\n\n        15 --&gt; F[NULL]:::black\n        15 --&gt; K[NULL]:::black</code></pre> <p>Aplicamos a rota\u00e7\u00e3o \u00e0 direita</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        14:::black --&gt; 10:::black\n        14 --&gt; 16:::black\n\n        10 --&gt; 3:::black\n        10 --&gt; 12:::black\n\n        16 --&gt; 17:::black\n        16 --&gt; 20:::black\n\n        3 --&gt; 1:::red\n        3 --&gt; 7:::red\n\n        12 --&gt; 11:::red\n        12 --&gt; D[NULL]:::black\n\n        17 --&gt; 15:::red\n        17 --&gt; E[NULL]:::black\n\n        20 --&gt; A[NULL]:::black\n        20 --&gt; J[NULL]:::black\n\n        1 --&gt; B[NULL]:::black\n        1 --&gt; H[NULL]:::black\n\n        7 --&gt; L[NULL]:::black\n        7 --&gt; M[NULL]:::black\n\n\n        11 --&gt; C[NULL]:::black\n        11 --&gt; I[NULL]:::black\n\n        15 --&gt; F[NULL]:::black\n        15 --&gt; K[NULL]:::black</code></pre> <p>Agora subimos a cor</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n        14:::black --&gt; 10:::black\n        14 --&gt; 16:::black\n\n        10 --&gt; 3:::red\n        10 --&gt; 12:::black\n\n        16 --&gt; 17:::black\n        16 --&gt; 20:::black\n\n        3 --&gt; 1:::black\n        3 --&gt; 7:::black\n\n        12 --&gt; 11:::red\n        12 --&gt; D[NULL]:::black\n\n        17 --&gt; 15:::red\n        17 --&gt; E[NULL]:::black\n\n        20 --&gt; A[NULL]:::black\n        20 --&gt; J[NULL]:::black\n\n        1 --&gt; B[NULL]:::black\n        1 --&gt; H[NULL]:::black\n\n        7 --&gt; L[NULL]:::black\n        7 --&gt; M[NULL]:::black\n\n\n        11 --&gt; C[NULL]:::black\n        11 --&gt; I[NULL]:::black\n\n        15 --&gt; F[NULL]:::black\n        15 --&gt; K[NULL]:::black</code></pre>"},{"location":"arvore/redblack/#filho-direito-de-um-no-vermelho","title":"Filho direito de um n\u00f3 vermelho","text":"<pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n    1[X]:::red --&gt; 2[NULL]:::black\n    1 --&gt; 3[NULL]:::black\n</code></pre> <p>Vamos inserir um filho \u00e0 direita de X e supondo que X tem uma raiz <code>r</code></p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n    1[r]:::black --&gt; 2\n    1 --&gt; 5[NULL]:::black\n    2[X]:::red --&gt; 3[NULL]:::black\n    2 --&gt; 4[Y]:::red</code></pre> <p>Aplicamos rota\u00e7\u00e3o \u00e0 esquerda em X</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n    1[r]:::black --&gt; 2\n    1 --&gt; 5[NULL]:::black\n    2[Y]:::red --&gt; 3[X]:::red\n    2 --&gt; 4[NULL]:::black</code></pre> <p>Aplicamos rota\u00e7\u00e3o \u00e0 direita em R</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n    1[Y]:::black --&gt; 2[X]:::red\n    1 --&gt; 3[r]:::red\n\n    2 --&gt; 4[NULL]:::black\n    2 --&gt; 5[NULL]:::black\n\n    3 --&gt; 6[NULL]:::black\n    3 --&gt; 7[Sub A]:::black</code></pre> <p>Agora subimos a cor</p> <pre><code>    graph TD\n    classDef red fill:#f00,color:#fff,stroke:#333,stroke-width:4px;\n    classDef black fill:#000,color:#fff,stroke:#333,stroke-width:4px;\n\n    1[Y]:::red --&gt; 2[X]:::black\n    1 --&gt; 3[r]:::black\n\n    2 --&gt; 4[NULL]:::black\n    2 --&gt; 5[NULL]:::black\n\n    3 --&gt; 6[NULL]:::black\n    3 --&gt; 7[Sub A]:::black</code></pre>"},{"location":"arvore/redblack/#funcao-implementada-com-as-correcoes","title":"Fun\u00e7\u00e3o implementada com as corre\u00e7\u00f5es","text":"<pre><code>int ehPreto(no *r){\n    if (r == NULL) return 1;\n    else return r-&gt;cor == PRETO;\n}\nint ehVermelho(no *r){\n    if (r == NULL) return 0;\n    else return r-&gt;cor == VERMELHO;\n}\nno *rotacaoEsquerda(no *r){\n    no *x = r-&gt;dir;\n    x-&gt;cor = r-&gt;cor;\n    r-&gt;cor = VERMELHO;\n    r-&gt;dir = x-&gt;esq;\n    x-&gt;esq = r;\n    return x;\n}\nno *rotacaoDireita(no *r){\n    no *x = r-&gt;esq;\n    x-&gt;cor = r-&gt;cor;\n    r-&gt;cor = VERMELHO;\n    r-&gt;esq = x-&gt;dir;\n    x-&gt;dir = r;\n    return x;\n}\nvoid sobeCor(no *r){\n    r-&gt;esq-&gt;cor = r-&gt;dir-&gt;cor = PRETO;\n    r-&gt;cor = VERMELHO;\n}\nno *corrige(no *r){\n    if (ehPreto(r-&gt;esq) &amp;&amp; ehVermelho(r-&gt;dir))\n        r = rotacaoEsquerda(r);\n    // o segundo if n\u00e3o tem problema de defini\u00e7\u00e3o: caso r-&gt;esq seja NULL, j\u00e1 retorna Falso\n    if (ehVermelho(r-&gt;esq) &amp;&amp; ehVermelho(r-&gt;esq-&gt;esq))\n        r = rotacaoDireita(r);\n    if (ehVermelho(r-&gt;esq)  &amp;&amp; ehVermelho(r-&gt;dir))\n        sobeCor(r);\n    return r;\n}\nno *insere(no *r, int x){\n    if (r == NULL){\n        no *novo = (no *) calloc(1, sizeof(no));\n        novo-&gt;chave = x;\n        novo-&gt;cor = VERMELHO;\n        return novo;\n    } else if (x &lt; r-&gt;chave) r-&gt;esq = insere(r-&gt;esq, x);\n    else if (x &gt; r-&gt;chave) r-&gt;dir = insere(r-&gt;dir, x);\n    /* corre\u00e7\u00e3o da sub\u00e1rvore com raiz r */\n    r = corrige(r);\n    return r;\n}\n\nno *insere_novo(no *r, int x){\n    r = insere(r,x);\n    r-&gt;cor = PRETO;\n    return r;\n} // pode ser que, ao final, a raiz principal tenha se tornado VERMELHA. Ent\u00e3o fazemos isso para garantir que se manter\u00e1 sempre PRETA\n</code></pre>"},{"location":"grafos/grafos/","title":"Grafo","text":"<p>Um grafo \u00e9 um conjunto de objetos interligados entre si. Os objetos s\u00e3o chamados de v\u00e9rtices e as liga\u00e7\u00f5es de arestas.</p> <p>Matematicamente, \u00e9 um par ordenado (V,A) em que V \u00e9 o conjunto de v\u00e9rtices e A \u00e9 o conjunto de arestas.</p> <pre><code>graph TD\n    2 --- 3\n    2 --- 5\n    2 --- 1\n    3 --- 5\n    1 --- 4\n    1 --- 0\n    4 --- 5\n    4 --- 0</code></pre> <p>No exemplo acima, temos um grafo com 6 v\u00e9rtices e 8 arestas.</p> <p>V = {0,1,2,3,4,5} A = {{0,1}, {0,4}, {1,2}, {1,4}, {2,3}, {2,5}, {3,5}, {4,5}}</p> <p>Se {u,v} \u00e9 uma aresta, dizemos que u e v s\u00e3o adjacentes.</p>"},{"location":"grafos/grafos/#representacao-de-um-grafo","title":"Representa\u00e7\u00e3o de um Grafo","text":""},{"location":"grafos/grafos/#matriz-de-adjacencia","title":"Matriz de Adjac\u00eancia","text":"<p>Uma matriz de adjac\u00eancia \u00e9 uma matriz quadrada de ordem igual ao n\u00famero de v\u00e9rtices do grafo. Seja G um grafo com n v\u00e9rtices, a matriz de adjac\u00eancia de G \u00e9 uma matriz n x n M tal que:</p> <p>M[i][j] = 1 se {i,j} \u00e9 uma aresta de G</p> 0 1 2 3 4 5 0 1 1 1 1 1 1 2 1 1 1 3 1 1 4 1 1 1 5 1 1 1 <p>Problema da esparcidade: Se o grafo \u00e9 muito esparso, a matriz de adjac\u00eancia \u00e9 uma matriz com muitos zeros.</p>"},{"location":"grafos/grafos/#lista-de-adjacencia","title":"Lista de Adjac\u00eancia","text":"<p>Uma lista de adjac\u00eancia \u00e9 uma lista de listas. Cada elemento da lista principal corresponde a um v\u00e9rtice do grafo. Cada elemento da lista interna corresponde a um v\u00e9rtice adjacente ao v\u00e9rtice correspondente da lista principal.</p>"},{"location":"grafos/grafos/#implementacao","title":"Implementa\u00e7\u00e3o","text":""},{"location":"grafos/grafos/#matriz-de-adjacencia_1","title":"Matriz de Adjac\u00eancia","text":"<pre><code>typedef struct {\n    int **adj;\n    int n;\n} grafo;\n\ngrafo *cria_grafo(int n){\n    grafo *g = (grafo *) malloc(sizeof(grafo));\n    g-&gt;n = n;\n    g-&gt;adj = (int **) malloc(n * sizeof(int *));\n    for(int i = 0; i &lt; n; i++){\n        g-&gt;adj[i] = (int *) calloc(n, sizeof(int));\n    }\n    return g;\n} // outra forma seria usar um \u00fanico calloc para alocar a matriz inteira: g-&gt;adj = (int **) calloc(n, sizeof(int **));\n</code></pre> <p>Para inserir uma aresta entre os v\u00e9rtices u e v:</p> <pre><code>g-&gt;adj[u][v] = g-&gt;adj[v][u] = 1;\n</code></pre> <p>As opera\u00e7\u00f5es de remo\u00e7\u00e3o e verifica\u00e7\u00e3o de exist\u00eancia de aresta s\u00e3o an\u00e1logas.</p>"},{"location":"grafos/grafos/#lista-de-adjacencia_1","title":"Lista de Adjac\u00eancia","text":"<pre><code>typedef struct no {\n    int v;\n    struct no *prox;\n} no;\n\ntypedef struct {\n    no *adj;\n    int n;\n} grafo;\n\ngrafo *cria_grafo(int n){\n    grafo *g = (grafo *) malloc(sizeof(grafo));\n    g-&gt;n = n;\n    g-&gt;adj = (no *) calloc(n, sizeof(no));\n    return g;\n}\n</code></pre> <p>A inser\u00e7\u00e3o consiste em inserir um n\u00f3 na lista de adjac\u00eancia do v\u00e9rtice u:</p> Matriz Lista Inser\u00e7\u00e3o O(1) O(\\delta_{max})  porque precisa verificar se a aresta existe ou n\u00e3o Remo\u00e7\u00e3o O(1) O(\\delta_{max}) Exist\u00eancia de Aresta O(1) O(\\delta_{max}) Espa\u00e7o O(n^2) O(m + n) ou O (2m + n)  m: total de arestas, n: total de v\u00e9rtices <p>\\delta_{max} \u00e9 o grau m\u00e1ximo do grafo. O grau de um v\u00e9rtice \u00e9 a quantidade de v\u00e9rtices adjacentes a ele. Vale salientar que \\delta_{max} pode ser n-1</p>"},{"location":"grafos/grafos/#exemplos","title":"Exemplos","text":""},{"location":"grafos/grafos/#o-vertice-mais-popular","title":"O v\u00e9rtice mais popular","text":"<p>Suponha o seguinte grafo</p> <pre><code>graph TD\n    1 --- 2\n    1 --- 0\n    1 --- 4\n    2 --- 3\n    2 --- 5\n    4 --- 0\n    5 --- 3\n    5 --- 0\n</code></pre> <p>Observa\u00e7\u00e3o: \u00e9 importante notar a forma como cada linguagem armazena matrizes. No caso da linguagem C, a matriz \u00e9 armazenada por linhas, ou seja, a matriz \u00e9 um vetor de vetores. Sendo assim, para verificar o vertice mais popular usando matriz de adjac\u00eancia, o desempenho ser\u00e1 muito maior se percorrermos a matriz por linhas ao inv\u00e9s de por colunas, pois evita saltos.</p> <pre><code>// usando matriz de adjac\u00eancia\nint mais_popular(grafo *g){\n    int grau_max = 0; v_max, grau;\n    for (int i = 0; i &lt; g-&gt;n; i++){\n        grau = 0;\n        for (int j = 0; j &lt; g-&gt;n; j++){\n            // if (g-&gt;adj[j][i]) grau++;  \n            grau += g-&gt;adj[i][j];\n        }\n        if (grau &gt;= grau_max){ // adicionando = para o caso onde o grafo tenha apenas um v\u00e9rtice\n            grau_max = grau;\n            v_max = i;\n        }\n    }\n    return v_max;\n} // complexidade O(n\u00b2)\n\n```c\n// usando lista de adjac\u00eancia\nint mais_popular(grafo *g){\n    int grau_max = 0, v_max, grau;\n    for (int i = 0; i &lt; g-&gt;n; i++){\n        grau = 0;\n        for (no *v = g-&gt;adj[i]-&gt;prox; v != NULL; v = v-&gt;prox){\n            grau++;\n        }\n        if (grau &gt;= grau_max){\n            grau_max = grau;\n            v_max = i;\n        }\n    }\n    return v_max;\n} // complexidade O(m), onde m \u00e9 O(n\u00b2) no pior caso. O pior caso ocorre quando o grafo \u00e9 completo (todos os v\u00e9rtices s\u00e3o adjacentes a todos os outros v\u00e9rtices)\n</code></pre>"},{"location":"grafos/grafos/#indicacao-de-conexao","title":"Indica\u00e7\u00e3o de conex\u00e3o","text":"<p>Dado um v\u00e9rtice <code>u</code>, queremos indicar conex\u00f5es para <code>u</code>.</p> <p>Se <code>u</code> \u00e9 adjacente \u00e0 <code>v</code> e <code>v</code> \u00e9 adjacente \u00e0 <code>w</code>, ent\u00e3o <code>w</code> \u00e9 uma indica\u00e7\u00e3o de conex\u00e3o de <code>u</code>.</p> <pre><code>// usando matriz de adjac\u00eancia\nvoid imprime_recomendacoes(grafo *g, int u){\n    int *rec = calloc(g-&gt;n, sizeof(int));\n    for (int v=0; v &lt; g-&gt;n; v++){\n        if (g-&gt;adj[v][u]){\n            for (int w=0; w &lt; g-&gt;n; w++){\n                if (g-&gt;adj[w][v] &amp;&amp; !g-&gt;adj[w][u]){\n                    rec[w] = 1; // se quisermos guardar a intensidade da recomenda\u00e7\u00e3o podemos incrementar rec[w] \n                }\n            }\n        }\n    }\n    for (int w=0; w &lt; g-&gt;n; w++){\n        if (rec[w]){\n            printf(\"%d \", w);\n        }\n    }\n} // complexidade O(n) ou O(delta_max) usando listas (onde delta_max \u00e9 o grau m\u00e1ximo do grafo)\n\n// usando lista de adjac\u00eancia\nvoid imprime_recomendacoes(grafo *g, int u){\n    int *rec = calloc(g-&gt;n, sizeof(int));\n    for (no *v = g-&gt;adj[u]-&gt;prox; v != NULL; v = v-&gt;prox){\n        for (no *w = g-&gt;adj[v-&gt;v]-&gt;prox; w != NULL; w = w-&gt;prox){\n            rec[w-&gt;v] = 1;\n        }\n        rec[v-&gt;v] = 0;\n    }\n    for (int i=0; i &lt; g-&gt;n; i++){\n        if (rec[i]){\n            printf(\"%d \", i);\n        }\n    }\n    printf(\"\\n\");\n    free(rec);\n}\n</code></pre>"},{"location":"grafos/grafos/#caminhos","title":"Caminhos","text":"<p>Um caminho entre dois v\u00e9rtices <code>u</code> e <code>v</code> \u00e9 uma sequ\u00eancia de v\u00e9rtices adjacentes, sem repeti\u00e7\u00e3o, come\u00e7ando em <code>u</code>  e terminando em <code>v</code>.</p>"},{"location":"grafos/grafos/#percurso-em-grafos","title":"Percurso em Grafos","text":"<pre><code>graph LR\n    0 --- 1\n    0 --- 4\n    4 --- 8\n    8 --- 9\n    8 --- 12\n    8 --- 13\n    1 --- 2\n    5 --- 9\n    5 --- 10\n    9 --- 10\n    13 --- 10\n    13 --- 14\n    2 --- 3\n    2 --- 6\n    6 --- 7\n    10 --- 14\n    14 --- 15\n    3 --- 7\n    6 --- 11\n    7 --- 11\n    1 --- 4\n    12 --- 9</code></pre>"},{"location":"grafos/grafos/#busca-em-profundidade-dfs-depth-first-search","title":"Busca em Profundidade - DFS (Depth First Search)","text":"<p>A busca em profundidade \u00e9 um algoritmo recursivo que explora o m\u00e1ximo poss\u00edvel de um ramo antes de retroceder.</p> <p>O resultado da busca em profundidade \u00e9 uma \u00e1rvore de profundidade, que pode ser armazenado em um vetor de pais.</p> <pre><code>graph LR\n\n0 --&gt; 1\n1 --&gt; 2\n1 --&gt; 4\n2 --&gt; 3\n3 --&gt; 7\n7 --&gt; 6\n6 --&gt; 11\n4 --&gt; 8\n8 --&gt; 9\n9 --&gt; 5\n9 --&gt; 12\n5 --&gt; 10\n10 --&gt; 13\n13 --&gt; 14\n14 --&gt; 15</code></pre> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pai 0 0 1 2 1 9 7 3 4 8 5 6 9 10 13 14 <pre><code>void dfs(grafo *g, int *pai, int p, int v){\n    pai[v] = p;\n    for (int i=0; i &lt; g-&gt;n; i++){\n        if (g-&gt;adj[v][i] &amp;&amp; pai[i] == -1){\n            dfs(g, pai, v, i);\n        }\n    }\n} // complexidade O(n), porque a cada chamada recursiva, o v\u00e9rtice \u00e9 marcado como visitado. O(n) recurs\u00f5es s\u00e3o feitas. Algumas literaturas consideram a complexidade O(n\u00b2)\nint *caminhos(grafo *g, int s){\n    int *pai = (int *) malloc(g-&gt;n * sizeof(int));\n    for (int i = 0; i &lt; g-&gt;n; i++) pai[i] = -1;\n    dfs(g, pai, s, s);\n    return pai;\n}\n\n// usando lista de adjacencia\nvoid dfs(grafo *g, int *pai, no *p, no *v){\n    pai[v-&gt;v] = p-&gt;v;\n    for (no *w = g-&gt;adj[v-&gt;v]-&gt;prox; w != NULL; w = w-&gt;prox){\n        if (pai[w-&gt;v] == -1){\n            dfs(g, pai, v, w);\n        }\n    }\n}\nint *caminhos(grafo *g, no *s){\n    int *pai = (int *) malloc(g-&gt;n * sizeof(int));\n    for (int i = 0; i &lt; g-&gt;n; i++) pai[i] = -1;\n    dfs(g, pai, s, s); // ou dfs(g, pai, g-&gt;adj[s], g-&gt;adj[s]) no caso de s ser um inteiro ao inv\u00e9s de n\u00f3\n    return pai;\n}\n</code></pre> <p>Exerc\u00edcio: Implementar a busca em profundidade usando pilha.</p>"},{"location":"grafos/grafos/#busca-em-largura-bfs-breadth-first-search","title":"Busca em Largura - BFS (Breadth First Search)","text":"<p>O resultado da busca em largura \u00e9 uma \u00e1rvore de largura e nos d\u00e1 os menores caminhos em saltos, que pode ser armazenado em um vetor de pais.</p> <pre><code>graph TD\n    0 --&gt; 1\n    0 --&gt; 4\n    1 --&gt; 2\n    4 --&gt; 8\n    2 --&gt; 3\n    3 --&gt; 6\n    8 --&gt; 9\n    8 --&gt; 12\n    8 --&gt; 13\n    3 --&gt; 7\n    6 --&gt; 11\n    9 --&gt; 5\n    9 --&gt; 10\n    13 --&gt; 14\n    14 --&gt; 15</code></pre> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pai 0 0 1 2 0 9 3 3 4 8 9 6 8 8 13 14 <pre><code>int *bfs(grafo *g, int v){\n    fila *f = cria_fila();\n    int *pai = (int *) malloc(g-&gt;n * sizeof(int));\n    for (int i = 0; i &lt; g-&gt;n; i++) pai[i] = -1;\n    pai[v] = v;\n    enfileira(f, v);\n    while (!fila_vazia(f)){\n        v = desenfileira(f);\n        for (int w = 0; w &lt; g-&gt;n; w++){\n            if (g-&gt;adj[v][w] &amp;&amp; pai[w] == -1){\n                pai[w] = v;\n                enfileira(f, w);\n            }\n        }\n    }\n    return pai;\n} // complexidade O(n\u00b2) ou O(|v|\u00b2), onde |v| \u00e9 a cardinalidade do conjunto de v\u00e9rtices\n\n// usando lista de adjac\u00eancia\nint *bfs(grafo *g, no *v){\n    fila *f = cria_fila();\n    int *pai = (int *) malloc(g-&gt;n * sizeof(int));\n    for (int i = 0; i &lt; g-&gt;n; i++) pai[i] = -1;\n    pai[v-&gt;v] = v-&gt;v;\n    enfileira(f, v);\n    while (!fila_vazia(f)){\n        v = desenfileira(f);\n        for (no *w = g-&gt;adj[v-&gt;v]-&gt;prox; w != NULL; w = w-&gt;prox){\n            if (pai[w-&gt;v] == -1){\n                pai[w-&gt;v] = v-&gt;v;\n                enfileira(f, w);\n            }\n        }\n    }\n    return pai;\n}\n</code></pre>"},{"location":"grafos/grafos/#aplicacoes-de-percursos","title":"Aplica\u00e7\u00f5es de Percursos","text":""},{"location":"grafos/grafos/#componentes-conexas","title":"Componentes Conexas","text":"<pre><code>graph TD\n    0((0)) --- 1((1))\n    1 --- 2((2))\n    1 --- 3((3))\n    2 --- 4((4))\n    3 --- 4\n    8((8)) --- 9((9))\n    9 --- 10((10))\n    5((5)) --- 6((6))\n    6 --- 7((7))\n    6 --- 11((11))\n    7 --- 11\n    12((12))</code></pre> <p>Componentes conexas s\u00e3o subgrafos G'= (V', A') de G, onde V' \u00e9 um subconjunto de V e A' \u00e9 um subconjunto de A, tal que, para quaisquer u,v \\in V', existe um caminho entre u e v.</p> <p>Como descobrir quantas e quais s\u00e3o as componentes conexas de um grafo?</p> <pre><code>void dfs(grafo *g, int *visitados, int comp, int v){\n    visitados[v] = comp;\n    for (int i=0; i &lt; g-&gt;n; i++){\n        if (g-&gt;adj[v][i] &amp;&amp; !visitados[i]){\n            dfs(g, visitados, comp, i);\n        }\n    }\n}\n\nint *comp_conexas(grafo *g){\n    int *visitados = (int *) calloc(g-&gt;n, sizeof(int));\n    int comp = 1;\n    for (int v=0; v &lt; g-&gt;n; v++){\n        if (!visitados[v]){\n            dfs(g, visitados, comp, v);\n            comp++;\n        }\n    }\n    return visitados;\n}\n</code></pre>"},{"location":"grafos/grafos/#ordenacao-topologica","title":"Ordena\u00e7\u00e3o Topol\u00f3gica","text":"<p>Suponha que voc\u00ea tenha uma lista de tarefas, uma dependente da outra.</p> <pre><code>graph TD\n    a --&gt; b\n    a --&gt; c\n    b --&gt; d\n    b --&gt; e\n    b --&gt; h\n    c --&gt; b\n    c --&gt; d\n    c --&gt; f\n    e --&gt; f\n    e --&gt; g\n    d --&gt; e\n    d --&gt; f\n    i --&gt; f\n    f --&gt; g</code></pre> <p>Vale observar que nessa aplica\u00e7\u00e3o, o grafo \u00e9 digirido. Ou seja, existe uma dire\u00e7\u00e3o da aresta, o que implica que o sentido entre um v\u00e9rtice e outro n\u00e3o necessariamente seja duplo. Na matriz de adjac\u00eancia, implica que a matriz n\u00e3o ser\u00e1 mais sim\u00e9trica.</p> <p>Caso b dependesse de d, d de c e c de b, ter\u00edamos um ciclo</p> <ul> <li>Um grafo n\u00e3o dirigido e sem ciclos \u00e9 uma \u00e1rvore</li> <li>Um grafo dirigido e sem ciclos \u00e9 um Grafo Dirigido Ac\u00edclico (DAG)</li> </ul> <pre><code>void dfs(grafo *g, int visitados, int v){\n    visitados[v] = 1;\n    for (no *w = g-&gt;adj[v]; w != NULL; w = w-&gt;prox){\n        if(!visitados[w-&gt;v]){\n            dfs(g, visitados, w-&gt;v);\n        }\n    printf(\"%d \", v);\n    }\n}\nvoid ord_topologica(grafo *g){\n    int *visitados = (int *) calloc(g-&gt;n, sizeof(int));\n    for (int v=0; v &lt; g-&gt;n; v++){ // se todas as tarefas n\u00e3o forem obrigat\u00f3rias, esse la\u00e7o n\u00e3o seria necess\u00e1rio\n        for (no *w = g-&gt;adj[v]; w != NULL; w = w-&gt;prox){\n            if (!visitados[w-&gt;v]) dfs(g, visitados, w-&gt;v);\n        }\n    }\n}\n</code></pre> <p>Sa\u00edda: g, f, e, d, h, b, c, a, i</p>"},{"location":"hash/tabela_hash/","title":"Tabela Hash","text":"<p>Ir para o Sum\u00e1rio</p>"},{"location":"hash/tabela_hash/#tabelas-de-dispersao-hashing","title":"Tabelas de Dispers\u00e3o (Hashing)","text":"<ul> <li>Conjunto universo de tamanho S</li> <li>Conjunto de dados de tamanho n</li> </ul> <p>M\u00e9todo entre busca sequencial e acesso direto</p> <p>Construir uma tabela de tamanho T &lt; S, atentando-se para:</p> <ul> <li>colis\u00e3o: duas chaves ocupam a mesma posi\u00e7\u00e3o na tabela</li> <li> <p>fun\u00e7\u00e3o de espalhamento: dado uma chave x, a posi\u00e7\u00e3o na tabela ser\u00e1 hash(x). hash: U -&gt; {0, 1, ..., T-1}</p> <p>a fun\u00e7\u00e3o hash n\u00e3o \u00e9 bijetora, ou seja, duas chaves distintas podem ter o mesmo hash</p> </li> </ul>"},{"location":"hash/tabela_hash/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Para implementar tabelas hash, precisamos de: 1. uma forma de armazenamento da tabela 2. uma fun\u00e7\u00e3o de espalhamento 3. um m\u00e9todo para lidar com colis\u00f5es</p>"},{"location":"hash/tabela_hash/#funcao-de-espalhamento","title":"Fun\u00e7\u00e3o de Espalhamento","text":"<p>A fun\u00e7\u00e3o hash ideal preencheria toda a tabela sem colis\u00f5es. A primeira colis\u00e3o aconteceria apenas quando n &gt; T (quando a tabela estivesse cheia). O nome dessa fun\u00e7\u00e3o hash ideal \u00e9 hash universal uniforme</p> <p>A fun\u00e7\u00e3o hash mais comum segue o m\u00e9todo da divis\u00e3o:</p> <pre><code>int hash(int x){\n    return x % T;\n}\n</code></pre>"},{"location":"hash/tabela_hash/#estrategias-para-armazenamento-e-lidar-com-colisoes","title":"Estrat\u00e9gias para armazenamento e lidar com colis\u00f5es","text":""},{"location":"hash/tabela_hash/#encadeamento-separado","title":"Encadeamento separado","text":"<p>Tabela de tamanho T de n\u00f3s-cabe\u00e7a. Cada n\u00f3-cabe\u00e7a aponta para uma lista encadeada de elementos.</p>"},{"location":"hash/tabela_hash/#implementacao_1","title":"Implementa\u00e7\u00e3o","text":"<p>Ideia de uma implementa\u00e7\u00e3o b\u00e1sica</p> <pre><code>typedef struct no{\n    int dado;\n    struct no *prox;\n} no;\n\ntypedef struct {\n    no *tab;\n    int T; // tamanho\n} TH;\n\nvoid cria_tabela(TH *h, int T); // alocar o h e a tabela\nvoid destroi_tabela(TH *h); // contrario do cria_tabela\nvoid insere(TH *h, int x);\nvoid remove(TH *h, int x);\nint busca(TH *h, int x);\n\n\nint busca(TH *h, int x){\n    no *p = h-&gt;tab[hash(x)]-&gt;prox;\n    while (p != NULL){\n        if (p-&gt;dado == x) return 1;\n        p = p-&gt;prox;\n    }\n    return 0;\n}\n// complexidade O(n/T) no caso m\u00e9dio. Nesse caso o s\u00edmbolo da complexidade adequado \u00e9 \u0398(n/T) ou O(\u03b4), onde \u03b4 \u00e9 o maior n\u00famero de colis\u00f5es na tabela.\n// Se esse \u03b4 for limitado, a complexidade \u00e9 O(1)\n</code></pre> <p>Portanto, uma boa implementa\u00e7\u00e3o de hash consiste em limitar o total de colis\u00f5es. Isso pode ser feito:</p> <ul> <li>escolhendo uma fun\u00e7\u00e3o hash \u00f3tima (pode exigir conhecimento sobre o conjunto de dados)</li> <li>limitar as colis\u00f5es na inser\u00e7\u00e3o (consequetemente, podemos ter tabela cheia, sendo poss\u00edvel redimensionar a tabela)</li> </ul>"},{"location":"hash/tabela_hash/#boas-escolhas-para-t-numeros-primos-preferencialmente-bem-maior-que-n","title":"Boas escolhas para T: n\u00fameros primos, preferencialmente bem maior que n","text":"<ul> <li>se a fun\u00e7\u00e3o hash for modular, e o n\u00famero primo s\u00f3 tem 2 divisores (1 e ele mesmo), a distribui\u00e7\u00e3o dos elementos na tabela ser\u00e1 mais uniforme, diminuindo a chance de colis\u00f5es</li> <li>Primos de Mersenne: 2^n - 1, onde n \u00e9 primo<ul> <li>tem ind\u00edcio de serem bons n\u00fameros primos</li> </ul> </li> </ul>"},{"location":"hash/tabela_hash/#enderecamento-aberto","title":"Endere\u00e7amento aberto","text":"<p>Consiste no uso de vetores para implementar tabelas hash</p> <p>Para resolu\u00e7\u00e3o de colis\u00f5es, h\u00e1 algumas t\u00e9cnicas, dentre as quais a mais comum chama-se sondegem linear: se houver colis\u00e3o, procura-se pela pr\u00f3xima \"posi\u00e7\u00e3o livre\" no vetor (pensando no conjunto universo de chaves positivas, a posi\u00e7\u00e3o livre poderia ser o -1)</p>"},{"location":"hash/tabela_hash/#exemplo","title":"Exemplo","text":"<p>T = 10</p> <p>chaves = {33, 36, 43, 77, 46, 56, 99}</p> insercao 0 1 2 3 4 5 6 7 8 9 sit inicial -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 -1 -1 -1 33 -1 -1 -1 -1 -1 -1 2 -1 -1 -1 33 -1 -1 36 -1 -1 -1 3 -1 -1 -1 33 43 -1 36 -1 -1 -1 4 -1 -1 -1 33 43 -1 36 77 -1 -1 5 -1 -1 -1 33 43 -1 36 77 46 -1 6 -1 -1 -1 33 43 -1 36 77 46 56 7 99 -1 -1 33 43 -1 36 77 46 56 <p>Vai ser boa quando a tabela for esparsa, quando n &lt; T, ou seja, quando possui \"muitos\" elementos vazios</p> <p>Densidade \u00e9 a porcentagem de elementos n\u00e3o-vazios do vetor.</p> \\text{Densidade} = \\frac{\\text{qtd de elementos n\u00e3o vazios}}{\\text{tamanho da tabela}} <p>Podemos dizer que um vetor \u00e9 esparso quando a densidade \u00e9 menor ou igual a 0.3</p> <p>Na pr\u00e1tica, quando a tabela hash atingir uma densidade D &lt; 1, podemos redimension\u00e1-la. Uma boa \u00e9 dobrar o tamanho.</p> <p>Ao redimensionar, \u00e9 necess\u00e1rio reinserir os elementos (pois T muda e, consequentemente, a fun\u00e7\u00e3o hash tamb\u00e9m muda)</p>"},{"location":"hash/tabela_hash/#implementacao_2","title":"Implementa\u00e7\u00e3o","text":"<p><pre><code>void insere(int ch){\n    pos = hash(ch);\n    while (v[pos] != -1){ // pode verificar se v[pos] == ch, caso necess\u00e1rio\n        pos = (pos + 1) % T;\n    }\n    v[pos] = ch;\n}\n</code></pre> <pre><code>int busca(int ch){\n    pos = hash(ch);\n    while (v[pos] != -1 &amp;&amp; v[pos] != ch){\n        pos = (pos + 1) % T;\n    }\n    if (v[pos] == ch) return 1;\n    return 0;\n}\n</code></pre> <pre><code>void remove(int ch){\n    pos = busca(ch);\n    if (pos &gt;= 0){\n        // v[pos] = -2;\n        v[pos] = -1;\n        pos = (pos + 1) % T;\n        while (v[pos] != -1){\n            int elem = v[pos];\n            v[pos] = -1;\n            insere(elem);\n            pos = (pos + 1) % T; \n        }\n    }\n\n\n}\n// reinserir na hash todos os elementos \u00e0 direita at\u00e9 encontrar vazio\n// Outra alternativa seria remover e marcar como dispon\u00edvel (posso inserir), mas n\u00e3o-vazio (busca n\u00e3o deve parar)\n</code></pre></p>"},{"location":"revisao/complexidade_ordenacao/","title":"Revis\u00e3o","text":"<p>Ir para o Sum\u00e1rio</p>"},{"location":"revisao/complexidade_ordenacao/#revisao-complexidade-e-ordenacao","title":"Revis\u00e3o (Complexidade e Ordena\u00e7\u00e3o)","text":""},{"location":"revisao/complexidade_ordenacao/#como-medir-desempenho","title":"Como medir desempenho?","text":"<ul> <li>algoritmo</li> <li>software/ programa</li> </ul> <p>Ex: multiplica\u00e7\u00e3o de matrizes</p> <p>C_{n \\times n} = A_{n \\times n} \\times B_{nxn} =&gt; c_{ij} = \\sum_{k=1}^{n} a_{ik} \\times b_{kj}</p> <ul> <li>O(n^3) opera\u00e7\u00f5es</li> </ul> <p>De forma impl\u00edcita, quando medimos o desempenho de um algoritmo, estamos medindo o tempo de execu\u00e7\u00e3o.</p> <pre><code>int maior(int *v, int n){\n    int m = v[0]; // executa 1 vez\n    for (int i = 1; i &lt; n; i++){\n        // 1      ;  n   ; n-1\n        if (v[i] &gt; m){ // n-1\n            m = v[i]; // no pior caso executa n-1\n        }\n    }\n    return m; // executa 1 vez\n\n    // 1 + 1 + n + n-1 + n-1 + n-1 + 1 &lt;= 4n\n}\n</code></pre> <p>Dizemos que f(n) \u00e9 O(g(n)) se existem constantes c e n0 tais que f(n) \\leq c \\cdot g(n) para todo n \\geq n0.</p> <p>A nota\u00e7\u00e3o assint\u00f3tica \u00e9 uma nota\u00e7\u00e3o matem\u00e1tica que descreve o comportamento de uma fun\u00e7\u00e3o quando o seu argumento tende a um valor espec\u00edfico ou ao infinito</p> <p>Tamb\u00e9m \u00e9 possivel representar como um limite tendendo a infinito:</p> <p>lim n -&gt; \u221e f(n)/g(n) = c</p>"},{"location":"revisao/complexidade_ordenacao/#outras-notacoes","title":"Outras nota\u00e7\u00f5es:","text":"<ul> <li>\u03a9(g(n)) - limite inferior</li> <li>\u0398(g(n)) - limite superior e inferior</li> <li>o(g(n)) - limite estritamente inferior</li> <li>\u03c9(g(n)) - limite estritamente superior</li> </ul>"},{"location":"revisao/complexidade_ordenacao/#gn-classicas","title":"g(n) cl\u00e1ssicas","text":"<ul> <li>1: constante</li> <li>log(n): logaritmo</li> <li>n: linear</li> <li>nlog(n): linear\u00edtmico</li> <li>n^k, k \\geq 2: polinomial</li> <li>k^n, k \\geq 2: exponencial<ul> <li>n! fatorial tamb\u00e9m \u00e9 considerado exponencial</li> </ul> </li> </ul>"},{"location":"revisao/complexidade_ordenacao/#exemplo","title":"Exemplo","text":"<p>Suponha um computador que consuma 0,001s por opera\u00e7\u00e3o.</p> n O(n) O(nlog(n)) O(n^2) O(n^3) O(2^n) 16 0,016s 0,064s 0,256s 4s 1m e 4s 32 0,032s 0,16s 1s 33s 46 dias 512 0,512s 9s 4m e 22s 1 dia e 3h 10^{137} s\u00e9c"},{"location":"revisao/complexidade_ordenacao/#lista-encadeada","title":"Lista Encadeada","text":"<p>S\u00e3o uma forma de armazenar um conjunto de dados alternativa a vetores.</p> <ul> <li>Cada elemento \u00e9 um n\u00f3</li> <li>Cada n\u00f3 cont\u00e9m um valor e um ponteiro para o pr\u00f3ximo n\u00f3</li> </ul> Vetores Listas cont\u00edguo n\u00e3o cont\u00edguo acesso direto O(1) acesso sequencial O(n) - n\u00e3o indexado aumentar custa O(n) aumentar custa O(1) diminuir custa O(n)  ou sub-utiliza diminuir custa O(1)"},{"location":"revisao/complexidade_ordenacao/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>typedef struct no{\n    int valor;\n    struct no *prox;\n} No;\n\n// descritor\ntypedef struct lista{\n    No *inicio;\n    int tamanho;\n    No *fim;\n} Lista;\n</code></pre> <p>N\u00f3-cabe\u00e7a: n\u00f3 que aponta para o primeiro n\u00f3 da lista</p>"},{"location":"revisao/complexidade_ordenacao/#ordenacao-por-intercalacao-mergesort","title":"Ordena\u00e7\u00e3o por Intercala\u00e7\u00e3o (MergeSort)","text":"<p>Baseado na Divis\u00e3o e Conquista e na recurs\u00e3o (bottom-up)</p> <p>Divis\u00e3o: divide o vetor \u201cao meio\u201d</p> <p>Conquista: intercale duas \u201cmetades\u201d (cada metade deve estar ordenada)</p> <p>Intercalar: consiste em combinar duas listas ordenadas em uma \u00fanica lista ordenada. Os elementos s\u00e3o comparados um a um e inseridos na nova lista na ordem correta.</p>"},{"location":"revisao/complexidade_ordenacao/#implementacao_1","title":"Implementa\u00e7\u00e3o","text":"<pre><code>// e: \u00edndice da esquerda\n// m: \u00edndice do meio\n// d: \u00edndice da direita\nvoid intercala (int *v, int e, int m, int d){\n    int *w = (int *) malloc (sizeof(int)*(d-e+1));\n    int i=e, j=m+1, k=0;\n    while (i &lt;= m &amp;&amp; j &lt;= d){\n        if (v[i] &lt; v[j]) w[k++] = v[i++];\n        else w[k++] = v[j++];\n    }\n    while (i &lt;= m) w[k++] = v[i++];\n    while (j &lt;= d) w[k++] = v[j++];\n    // esses ultimos dois la\u00e7os sao mutuamente exclusivos\n    for (k=0, i=e; i&lt;=d; i++, k++) v[i] = w[k];\n    free(w);\n} // complexidade 2*O(d-e+1)\n\nvoid mergesort (int *v, int e, int d){\n    if (e &lt; d){\n        int m = (e+d)/2;\n        mergesort (v, e, m);\n        mergesort (v, m+1, d);\n        intercala (v, e, m, d);\n    }\n}\n</code></pre> <pre><code>graph TD\n    A[-1 2 3 4 5 7 8 9] --&gt; B[-1 2 3 4] --&gt; C[-1 2] --&gt; D[-1]\n    B --&gt; L[3 4] --&gt; M[3]\n    L --&gt; N[4]\n    A --&gt; E[5 7 8 9] --&gt; F[5 7] --&gt; G[5]\n    F --&gt; O[7]\n    C --&gt; H[2]\n    E --&gt; I[8 9] --&gt; J[9]\n    I --&gt; K[8]\n\n    D --&gt; P[-1 2]\n    H --&gt; P\n\n    M --&gt; R[3 4]\n    N --&gt; R\n\n    G --&gt; S[5 7]\n    O --&gt; S\n\n    K --&gt; Q[8 9]\n    J --&gt; Q\n\n    P --&gt; T[-1 2 3 4]\n    R --&gt; T\n\n    S --&gt; U[5 7 8 9]\n    Q --&gt; U\n\n    T --&gt; V[-1 2 3 4 5 7 8 9]\n    U --&gt; V</code></pre> <p>An\u00e1lise da complexidade no google Fotos</p>"},{"location":"revisao/complexidade_ordenacao/#quicksort-ordenacao-por-particao","title":"QuickSort (Ordena\u00e7\u00e3o por Parti\u00e7\u00e3o)","text":"<p>Tamb\u00e9m baseado na Divis\u00e3o e Conquista e na recurs\u00e3o (top-down)</p> <p>A cada divis\u00e3o, resolve o problema da separa\u00e7\u00e3o (ou particionamento)</p> <p>Particionamento: escolhe um elemento (piv\u00f4) e rearranja o vetor de forma que todos os elementos menores que o piv\u00f4 fiquem \u00e0 esquerda e todos os elementos maiores fiquem \u00e0 direita</p> <p>Dado um vetor v[e...d], queremos definir um \u00edndice j tal que v[e...j-1] &lt;= v[j] &lt; v[j+1...d]</p>"},{"location":"revisao/complexidade_ordenacao/#como-resolver-um-particionamento","title":"Como resolver um particionamento","text":"<ol> <li>Escolher arbitrariamente um elemento do vetor (piv\u00f4)</li> <li>Encontrar o \u00edndice j e posicionar o piv\u00f4 neste \u00edndice de tal forma que v[e...j-1] &lt;= v[j] &lt; v[j+1...d]</li> </ol> \\leq p \\leq p \\leq p p &gt; p &gt; p &gt; p ? ? ? ? e j k d <ul> <li>se v[k] &gt; p, mantenha onde est\u00e1 e incrementa k</li> <li>se v[k] &lt;= p, troque v[k] com v[j] e incrementa j e k</li> </ul>"},{"location":"revisao/complexidade_ordenacao/#exemplo_1","title":"Exemplo","text":"3 -1 2 10 4 7 -2 5 3 5 jk p 3 -1 5 jk p 3 -1 2 5 jk p 3 -1 2 10 5 j k p 3 -1 2 4 10 5 j k p 3 -1 2 4 10 7 5 j k p 3 -1 2 4 -2 7 10 5 j pk 3 -1 2 4 -2 5 10 7 j pk"},{"location":"revisao/complexidade_ordenacao/#implementacao_2","title":"Implementa\u00e7\u00e3o","text":"<pre><code>void troca(int *a, int *b){\n    // o * \u00e9 o operador un\u00e1rio, faz o dereferenciamento (acessa o endereco de memoria e pega o valor armazenado nele)\n    int aux = *a;\n    *a = *b;\n    *b = aux;\n}\n\nint particiona(int *v, int e, int d){\n    int p = v[d], j, k;\n    for (k=e, j=e; k &lt; d; k++){\n        if (v[k] &lt;= p){\n            troca(&amp;v[k], &amp;v[j]);\n            j++;\n        }\n    }\n    troca(&amp;v[j], &amp;v[d]);\n    return j;\n} // complexidade O(d-e+1)\nvoid quicksort(int *v, int e, int d){\n    if (e &lt; d){\n        int j = particiona(v, e, d);\n        quicksort(v, e, j-1);\n        quicksort(v, j+1, d);\n    }\n} // complexidade O(n\u00b2) para o pior caso\n// com a mediana de 3, \u00e9 poss\u00edvel melhorar o quicksort. No caso m\u00e9dio, a complexidade \u00e9 O(nlog(n))\n</code></pre> <pre><code>graph TD\n    A[3 -1 2 10 4 7 -2 5]\n    A --&gt; B[3 -1 2 4 -2 5 10 7]\n    B --&gt; C[3 -1 2 4 -2]\n    C --&gt; E[-2 -1 2 4 3]\n\n    B --&gt; D[10 7]\n    D --&gt; P[vazio]\n    D --&gt; O[10]\n\n\n    E --&gt; Q[vazio]\n    E --&gt; F[-1 2 4 3]\n    F --&gt; G[-1 2 3 4]\n\n    G --&gt; H[-1 2]\n    G --&gt; J[4]\n\n    H --&gt; K[-1]\n    H --&gt; R[vazio]</code></pre>"},{"location":"revisao/complexidade_ordenacao/#estabilidade","title":"Estabilidade","text":"<p>O quicksort n\u00e3o \u00e9 est\u00e1vel, pois a ordem relativa dos elementos iguais n\u00e3o \u00e9 preservada.</p>"},{"location":"revisao/complexidade_ordenacao/#exemplo_2","title":"Exemplo","text":"3_a 3_b 2 kj j k j k 2 3_b 3_a"},{"location":"revisao/complexidade_ordenacao/#exercicio","title":"Exerc\u00edcio","text":"<p>Como implementar o quicksort est\u00e1vel?</p>"},{"location":"revisao/complexidade_ordenacao/#problema-como-encontrar-o-k-esimo-menor-elemento-de-um-vetor","title":"Problema: Como encontrar o k-\u00e9simo menor elemento de um vetor?","text":"<p>Quando k=1, o custo \u00e9 O(n)</p> <p>Para k=&gt;2:</p> <ul> <li>Ordena, recupera o elemento na posi\u00e7\u00e3o k (ou k-1). O custo \u00e9 O(nlogn)</li> </ul>"},{"location":"revisao/complexidade_ordenacao/#e-se-ordenarmos-parcialmente","title":"E se ordenarmos parcialmente?","text":"<p>Separa: Dado um vetor v[e...d], queremos definir um \u00edndice j tal que v[e...j-1] &lt;= v[j] &lt; v[j+1...d]</p> <p>Resolver esse problema significa:</p> <ul> <li>Encontrar a posi\u00e7\u00e3o \"correta\" (no vetor ordenado) do piv\u00f4</li> <li>Rearranja o vetor de tal forma que todos os elementos menores que o piv\u00f4 fiquem \u00e0 esquerda e todos os elementos maiores fiquem \u00e0 direita</li> </ul>"},{"location":"revisao/complexidade_ordenacao/#quickselect","title":"QuickSelect","text":"<p>O separa retorna o j. Se k=j, ent\u00e3o j\u00e1 encontramos o k-\u00e9simo menor elemento. Se k \\lt j, ent\u00e3o o k-\u00e9simo menor elemento est\u00e1 \u00e0 esquerda de j. Se k\\gt j, ent\u00e3o o k-\u00e9simo menor elemento est\u00e1 \u00e0 direita de j.</p> <p>Para encontrar o k-\u00e9simo menor elemento:</p> <ul> <li>Se k \\lt j, aplico separa\u00e7\u00e3o \u00e0 esquerda</li> <li>Se k \\gt j, aplico separa\u00e7\u00e3o \u00e0 direita</li> </ul> <p>Esse algoritmo \u00e9 conhecido como QuickSelect</p> <pre><code>void quickselect(int *v, int e, int d, int k){\n    if (e &lt; d){\n        // escolha do pivo (mediana de 3) para evitar o pior caso O(n\u00b2)\n        int j = particiona(v, e, d);\n        // if (k == j) return;\n        if (k &lt; j) quickselect(v, e, j-1, k);\n        if (k &gt; j) quickselect(v, j+1, d, k);\n    }\n}\n</code></pre>"},{"location":"revisao/complexidade_ordenacao/#desempenho","title":"Desempenho","text":"<p> 1\u00aa 2\u00aa 3 .... n\u00aa n n/2 + \\color{green}c n/4 + \\color{green}c .... 1 <p>log_n</p> <p></p> S = \\frac{1(2^{lg_2n}-1)}{2-1} = n-1 + {\\color{green}c \\times log_n} = O(n)"},{"location":"revisao/complexidade_ordenacao/#tipo-de-aplicacao","title":"Tipo de aplica\u00e7\u00e3o","text":"<ul> <li>Listar os 100 primeiros elementos de um vetor de alunos ordenados pelo IRA:<ul> <li>Encontrar o 100\u00ba menor elemento</li> <li>Todos os elementos \u00e0 esquerda s\u00e3o menor que o 100\u00ba menor elemento</li> <li>Agora basta ordenar esses 100 elementos</li> <li>\u00c9 muito mais barato ordenar apenas 100 elementos do que ordenar todos os elementos</li> </ul> </li> </ul>"},{"location":"revisao/complexidade_ordenacao/#algoritmos-de-ordenacao-lineares-on","title":"Algoritmos de Ordena\u00e7\u00e3o Lineares O(n)","text":"<p>Sempre partem de uma 'premissa' sobre o conjunto de dados.</p>"},{"location":"revisao/complexidade_ordenacao/#contagem-counting-sort","title":"Contagem (Counting Sort)","text":"<p>Premissa: todo elemento do vetor s\u00e3o inteiros e est\u00e3o no intervalo entre a e b</p> <ol> <li>Crie um vetor auxiliar c de tamanho b-a+1 e inicialize com 0</li> <li>Percorra o vetor v e conte a frequ\u00eancia de cada elemento</li> <li>Percorra o vetor c e acumule a frequ\u00eancia</li> <li>Percorra o vetor v de tr\u00e1s para frente e posicione o elemento na posi\u00e7\u00e3o correta</li> </ol> <pre><code>graph TD\n    A[5 3 2 4 9 5 3 1 3 8]\n    B[0 0 0 0 0 0 0 0 0 0]\n    B --&gt;|5 uma vez| C[0 0 0 0 1 0 0 0 0 0]\n    C --&gt;|3 uma vez| D[0 0 1 0 1 0 0 0 0 0]\n    D --&gt;|2 uma vez| E[0 1 1 0 1 0 0 0 0 0]\n    E --&gt;|4 uma vez| F[0 1 1 1 1 0 0 0 0 0]\n    F --&gt;|9 uma vez| G[0 1 1 1 1 0 0 0 1 0]\n    G --&gt;|5 duas vezes| H[0 1 1 1 2 0 0 0 1 0]\n    H --&gt;|3 duas vezes| I[0 1 2 1 2 0 0 0 1 0]\n    I --&gt;|1 uma vez| J[1 1 2 1 2 0 0 0 1 0]\n    J --&gt;|3 tres vezes| K[1 1 3 1 2 0 0 0 1 0]\n    K --&gt;|8 uma vez| L[1 1 3 1 2 0 0 1 1 0]\n</code></pre>"},{"location":"revisao/complexidade_ordenacao/#complexidade-onb-a1","title":"Complexidade: O(n+b-a+1)","text":"<p>\u00c9 vantajoso quando o tamanho do intervalo \"pequeno\" (neste caso, O(n))</p>"},{"location":"revisao/complexidade_ordenacao/#radix-sort-ordenacao-por-destribuicao","title":"Radix Sort (Ordena\u00e7\u00e3o por destribui\u00e7\u00e3o)","text":"<p>Premissa: O conjunto \u00e9 formado por inteiros positivos com, no m\u00e1ximo, k d\u00edgitos</p> <p>Esse algoritmo percorre o vetor k vezes analisando os dig\u00edtos menos significativos para os mais significativos.</p> <p>Tamb\u00e9m usa 10 filas auxiliares (uma para cada d\u00edgito de 0 a 9)</p> <p>Em um exemplo de 2 d\u00edgitos, o algoritmo percorre o vetor duas vezes, uma para as unidades e outra para as dezenas.</p> <p>\u00c9 vantajoso quando k for O(log n)</p>"},{"location":"revisao/complexidade_ordenacao/#complexidade","title":"Complexidade","text":"<p>O(nk)</p>"},{"location":"revisao/problemaBusca/","title":"Problema de Busca","text":"<p>Ir para o Sum\u00e1rio</p>"},{"location":"revisao/problemaBusca/#o-problema-de-busca","title":"O problema de busca","text":"<p>Consiste em determinar de um elemento x pertence ou n\u00e3o a um determinado conjunto</p> <p>Suponho que temos:</p> <ul> <li>Um conjunto universo com S elementos</li> <li>Um conjunto de dados com N elementos</li> <li>Deseja-se realizar M consultas</li> </ul>"},{"location":"revisao/problemaBusca/#1-busca-sequencial","title":"1. Busca Sequencial","text":"<pre><code>int busca(int *v, int n, int x){\n    for (int i=0; i &lt; n; i++){\n        if (v[i] == x) return 1;\n    }\n    return 0;\n}\n// Considerando que queremos realizar M consultas, o custo total \u00e9 O(M.n)\n</code></pre>"},{"location":"revisao/problemaBusca/#2-busca-binaria","title":"2. Busca Bin\u00e1ria","text":"<p><pre><code>// Busca chave no vetor ordenado V[0..n-1]\nint buscaBinaria(int *v, int n, int chave){\n    int inicio, final, meio;\n    inicio = 0;\n    final = n - 1;\n    while(inicio &lt;= final){\n        meio = (inicio + final)/2;\n        if (chave == v[meio])\n            return meio;\n        if (chave &lt; v[meio])\n            final = meio - 1; // busca nos valores menores\n        else\n            inicio = meio + 1; // busca nos valores maiores\n    }\n    return -1; // chave n\u00e3o encontrada\n}\n</code></pre> Premissa: o conjunto precisa estar ordenado.</p> <p>Para realizar M consultas:</p> <ol> <li>Ordenar v O(n.log n)</li> <li>Aplicar M buscas bin\u00e1rias O(M.log n)</li> </ol> <p>Logo o custo total \u00e9: O(n.log n) + O(M.log n) = O((M+n).log n)</p> <p>At\u00e9 o momento 1 compensa se m for O(1). Se m for O(log n) s\u00e3o similares. Demais casos, 2 \u00e9 mais r\u00e1pido</p>"},{"location":"revisao/problemaBusca/#3-enderecamento-direto","title":"3. Endere\u00e7amento direto","text":"<ol> <li>Uso um vetor V de 0's e 1's de tamanho S</li> <li>Pra cada elemento y do conjunto, marco: V[y-offset] = 1, os demais s\u00e3o 0.<ul> <li>offset \u00e9 o menor valor do conjunto universo </li> </ul> </li> </ol> <pre><code>int busca(char *v, int x){\n    return v[x-OFFSET];\n} // Considerando M consultas, o custo total \u00e9 O(M) + O(S) de mem\u00f3ria auxiliar\n</code></pre>"},{"location":"revisao/problemaBusca/#4-tabela-de-dispersao-tabela-hash","title":"4. Tabela de dispers\u00e3o (Tabela Hash)","text":"<p>Cada chave \u00e9 mapeada em uma tabela (vetor ou lista encadeada), cuja posi\u00e7\u00e3o \u00e9 determinada por uma fun\u00e7\u00e3o de espalhamento (fun\u00e7\u00e3o hash)</p> <p>A ideia \u00e9 que o tamanho da tabela seja menor que o conjunto universo (S). Nesse caso, pode ocorrer uma colis\u00e3o, ou seja, duas chaves distintas serem mapeadas para a mesma posi\u00e7\u00e3o da tabela.</p> <p>Uma chave pode ocupar uma \u00fanica posi\u00e7\u00e3o, mas uma posi\u00e7\u00e3o pode ser ocupada por v\u00e1rias chaves Uma famosa tabela hash da matem\u00e1tica \u00e9 o c\u00edrculo trigonom\u00e9trico</p>"}]}